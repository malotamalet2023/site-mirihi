import { NextRequest, NextResponse } from 'next/server';
import { GoogleGenerativeAI } from '@google/generative-ai';

// Utiliser la variable d'environnement correcte
const API_KEY = process.env.GOOGLE_GENERATIVE_AI_API_KEY || process.env.GOOGLE_GEMINI_API_KEY;

if (!API_KEY) {
  console.warn('‚ö†Ô∏è Cl√© API Gemini non configur√©e. L\'analyse IA utilisera le fallback.');
}

const genAI = API_KEY ? new GoogleGenerativeAI(API_KEY) : null;

// Fonctions utilitaires
function getMaturityLevel(score: number): string {
  if (score >= 85) return 'Expert';
  if (score >= 70) return 'Avanc√©';
  if (score >= 50) return 'Interm√©diaire';
  return 'D√©butant';
}

function formatDomainName(domain: string): string {
  return domain
    .replace(/([A-Z])/g, ' $1')
    .replace(/^./, str => str.toUpperCase())
    .trim();
}

function getPerformanceIndicator(score: number): string {
  if (score >= 80) return 'üü¢ Excellent';
  if (score >= 60) return 'üü° Satisfaisant';
  if (score >= 40) return 'üü† √Ä am√©liorer';
  return 'üî¥ Critique';
}

function generateIntelligentInsights(data: any): string {
  const { overallScore, criticalDomains, excellentDomains } = data;
  
  let insights = `Votre diagnostic r√©v√®le un profil achats avec un score global de ${overallScore}% (niveau ${getMaturityLevel(overallScore)}). `;
  
  if (excellentDomains.length > 0) {
    insights += `Vos points forts incluent ${excellentDomains.map(([domain, score]: [string, number]) => formatDomainName(domain)).join(', ')}, d√©montrant une maturit√© remarquable dans ces domaines. `;
  }
  
  if (criticalDomains.length > 0) {
    insights += `Les axes d'am√©lioration prioritaires concernent ${criticalDomains.map(([domain, score]: [string, number]) => formatDomainName(domain)).join(', ')}, repr√©sentant des opportunit√©s concr√®tes d'optimisation. `;
  } else {
    insights += 'Aucun domaine critique n\'a √©t√© identifi√©, ce qui t√©moigne d\'une base solide. ';
  }
  
  insights += `Cette combinaison de forces et d'opportunit√©s vous positionne favorablement pour une mont√©e en maturit√© progressive et efficace.`;
  
  return insights;
}

function generateSmartRecommendations(data: any): string[] {
  const { criticalDomains, excellentDomains, overallScore } = data;
  const recommendations: string[] = [];
  
  if (criticalDomains.length > 0) {
    const topCritical = criticalDomains[0][0];
    recommendations.push(`Prioriser l'am√©lioration de ${formatDomainName(topCritical)} pour un impact rapide sur la performance globale`);
  }
  
  if (excellentDomains.length > 0) {
    recommendations.push(`Capitaliser sur vos forces en ${excellentDomains.map(([domain, score]: [string, number]) => formatDomainName(domain)).join(' et ')} pour cr√©er des synergies`);
  }
  
  if (overallScore < 60) {
    recommendations.push('Commencer par le diagnostic Maturit√© MMCM pour une √©valuation approfondie des fondamentaux');
  } else if (overallScore >= 60 && overallScore < 80) {
    recommendations.push('Utiliser le diagnostic Orientation Strat√©gique pour affiner l\'alignement avec les objectifs business');
  }
  
  recommendations.push('D√©finir un plan d\'action avec objectifs SMART et m√©triques de suivi');
  
  return recommendations.slice(0, 4);
}

function generateActionableSteps(data: any): string[] {
  const { criticalDomains, overallScore } = data;
  const steps: string[] = [];
  
  if (criticalDomains.length > 0) {
    steps.push(`R√©aliser un diagnostic d√©taill√© du domaine ${formatDomainName(criticalDomains[0][0])} dans les 30 prochains jours`);
  }
  
  steps.push('Constituer une √©quipe projet avec sponsor ex√©cutif et ressources d√©di√©es');
  steps.push('√âtablir un baseline d√©taill√© avec indicateurs de performance actuels');
  
  if (overallScore < 70) {
    steps.push('Planifier des formations cibl√©es pour d√©velopper les comp√©tences critiques');
  } else {
    steps.push('Mettre en place des initiatives d\'innovation collaborative avec les fournisseurs cl√©s');
  }
  
  return steps.slice(0, 4);
}

export async function POST(request: NextRequest) {
  try {
    const data = await request.json();
    
    // V√©rifier si Gemini est disponible
    if (!genAI) {
      console.log('üîÑ Gemini non configur√©, utilisation du fallback intelligent');
      return NextResponse.json(await generateFallbackAnalysis(data));
    }

    // Pr√©parer les donn√©es pour Gemini
    const analysisData = prepareDataForAnalysis(data);
    
    // G√©n√©rer l'analyse avec Gemini
    const analysis = await generateGeminiAnalysis(analysisData);
    
    console.log('‚úÖ Analyse Gemini g√©n√©r√©e avec succ√®s');
    return NextResponse.json(analysis);

  } catch (error) {
    console.error('‚ùå Erreur dans l\'analyse:', error);
    
    // Fallback intelligent en cas d'erreur
    const fallbackAnalysis = await generateFallbackAnalysis(await request.json());
    return NextResponse.json(fallbackAnalysis);
  }
}

// Fonction pour pr√©parer les donn√©es pour l'analyse
function prepareDataForAnalysis(data: any) {
  const { answers = [], categoryScores = {}, overallScore = 0, strengths = [], weaknesses = [] } = data;

  // Pr√©parer les pourcentages par cat√©gorie
  const percentages = Object.entries(categoryScores).reduce((acc, [category, data]: [string, any]) => {
    acc[category] = data.percentage || 0;
    return acc;
  }, {} as Record<string, number>);

  // Pr√©parer les r√©ponses d√©taill√©es
  const answersDetail = answers.map((answer: any) => ({
    category: answer.category,
    question: answer.question,
    response: answer.answer,
    score: answer.score
  }));

  // Identifier les domaines critiques (< 40%) et excellents (> 80%)
  const criticalDomains = Object.entries(percentages).filter(([, score]) => score < 40);
  const excellentDomains = Object.entries(percentages).filter(([, score]) => score > 80);

  return {
    overallScore,
    percentages,
    strengths,
    weaknesses,
    answersDetail: answersDetail.slice(0, 8), // Limiter pour l'API
    criticalDomains,
    excellentDomains,
    avgScore: Object.values(percentages).reduce((a, b) => a + b, 0) / Object.keys(percentages).length
  };
}

// G√©n√©ration d'analyse avec Gemini enrichie
async function generateGeminiAnalysis(data: any) {
  if (!genAI) throw new Error('Gemini non disponible');

  const model = genAI.getGenerativeModel({ 
    model: "gemini-1.5-flash",
    generationConfig: {
      temperature: 0.8, // Plus cr√©atif pour des insights personnalis√©s
      topK: 40,
      topP: 0.95,
      maxOutputTokens: 3000, // Plus de tokens pour une analyse approfondie
    }
  });

  // Prompt enrichi et structur√© pour Gemini
  const enhancedPrompt = `Tu es un consultant senior expert en procurement avec 15+ ans d'exp√©rience. Analyse ce diagnostic achats et fournis une analyse personnalis√©e de haute qualit√©.

üìä **DONN√âES DU DIAGNOSTIC:**

Score Global: ${data.overallScore}% (Niveau: ${getMaturityLevel(data.overallScore)})

Scores par Domaine:
${Object.entries(data.percentages).map(([domain, score]) => 
  `‚Ä¢ ${formatDomainName(domain)}: ${score}% ${getPerformanceIndicator(score as number)}`
).join('\n')}

Domaines Critiques (< 40%):
${data.criticalDomains.length > 0 ? 
  data.criticalDomains.map(([domain, score]: [string, number]) => `‚Ä¢ ${formatDomainName(domain)}: ${score}%`).join('\n') : 
  '‚Ä¢ Aucun domaine critique identifi√©'}

Domaines d'Excellence (> 80%):
${data.excellentDomains.length > 0 ? 
  data.excellentDomains.map(([domain, score]: [string, number]) => `‚Ä¢ ${formatDomainName(domain)}: ${score}%`).join('\n') : 
  '‚Ä¢ Aucun domaine d\'excellence identifi√©'}

üéØ CONTEXTE MIRIHI:
Mirihi propose des diagnostics sp√©cialis√©s pour optimiser les achats.

üöÄ MISSION:
G√©n√®re une analyse JSON avec:
{
  "insights": "Analyse personnalis√©e (200-250 mots, ton expert mais accessible)",
  "recommendations": ["4-5 recommandations concr√®tes et actionnables"],
  "nextSteps": ["4-5 √©tapes op√©rationnelles s√©quenc√©es"]
}

JSON valide uniquement, sans markdown.`;

  try {
    const result = await model.generateContent(enhancedPrompt);
    const response = await result.response;
    const analysisText = response.text().trim();

    // Nettoyer le texte pour extraire le JSON
    let cleanJson = analysisText;
    if (cleanJson.includes('```json')) {
      cleanJson = cleanJson.split('```json')[1].split('```')[0].trim();
    } else if (cleanJson.includes('```')) {
      cleanJson = cleanJson.split('```')[1].split('```')[0].trim();
    }

    // Parser le JSON
    const analysis = JSON.parse(cleanJson);
    
    // Validation et enrichissement
    if (!analysis.insights || !analysis.recommendations || !analysis.nextSteps) {
      throw new Error('Structure JSON incompl√®te');
    }

    // Enrichir avec des donn√©es contextuelles
    analysis.metadata = {
      generatedAt: new Date().toISOString(),
      geminiModel: "gemini-1.5-flash",
      overallScore: data.overallScore,
      maturityLevel: getMaturityLevel(data.overallScore),
      priorityDomains: data.criticalDomains.map(([domain]: [string, number]) => formatDomainName(domain))
    };

    return analysis;

  } catch (parseError) {
    console.error('‚ùå Erreur parsing Gemini:', parseError);
    throw new Error('R√©ponse Gemini invalide');
  }
}

// Fallback intelligent en cas d'indisponibilit√© de Gemini
async function generateFallbackAnalysis(data: any): Promise<any> {
  const analysisData = prepareDataForAnalysis(data);
  
  // Logique intelligente bas√©e sur les scores
  const insights = generateIntelligentInsights(analysisData);
  const recommendations = generateSmartRecommendations(analysisData); 
  const nextSteps = generateActionableSteps(analysisData);

  return {
    insights,
    recommendations,
    nextSteps,
    metadata: {
      generatedAt: new Date().toISOString(),
      source: "fallback-intelligent",
      overallScore: analysisData.overallScore,
      maturityLevel: getMaturityLevel(analysisData.overallScore)
    }
  };
}

export async function POST(request: NextRequest) {
  try {
    const data = await request.json();
    const { answers = [], categoryScores = {}, overallScore = 0, strengths = [], weaknesses = [] } = data;

    // V√©rifier si Gemini est disponible
    if (!genAI) {
      console.log('üîÑ Gemini non configur√©, utilisation du fallback intelligent');
      return NextResponse.json(await generateFallbackAnalysis(data));
    }

    // Pr√©parer les donn√©es pour Gemini
    const analysisData = prepareDataForAnalysis(data);
    
    // G√©n√©rer l'analyse avec Gemini
    const analysis = await generateGeminiAnalysis(analysisData);
    
    console.log('‚úÖ Analyse Gemini g√©n√©r√©e avec succ√®s');
    return NextResponse.json(analysis);

  } catch (error) {
    console.error('‚ùå Erreur dans l\'analyse:', error);
    
    // Fallback intelligent en cas d'erreur
    const fallbackAnalysis = await generateFallbackAnalysis(await request.json());
    return NextResponse.json(fallbackAnalysis);
  }
}

// Fonction pour pr√©parer les donn√©es pour l'analyse
function prepareDataForAnalysis(data: any) {
  const { answers = [], categoryScores = {}, overallScore = 0, strengths = [], weaknesses = [] } = data;

  // Pr√©parer les pourcentages par cat√©gorie
  const percentages = Object.entries(categoryScores).reduce((acc, [category, data]: [string, any]) => {
    acc[category] = data.percentage || 0;
    return acc;
  }, {} as Record<string, number>);

  // Pr√©parer les r√©ponses d√©taill√©es
  const answersDetail = answers.map((answer: any) => ({
    category: answer.category,
    question: answer.question,
    response: answer.answer,
    score: answer.score
  }));

  // Identifier les domaines critiques (< 40%) et excellents (> 80%)
  const criticalDomains = Object.entries(percentages).filter(([, score]) => score < 40);
  const excellentDomains = Object.entries(percentages).filter(([, score]) => score > 80);

  return {
    overallScore,
    percentages,
    strengths,
    weaknesses,
    answersDetail: answersDetail.slice(0, 8), // Limiter pour l'API
    criticalDomains,
    excellentDomains,
    avgScore: Object.values(percentages).reduce((a, b) => a + b, 0) / Object.keys(percentages).length
  };
}

// G√©n√©ration d'analyse avec Gemini enrichie
async function generateGeminiAnalysis(data: any) {
  if (!genAI) throw new Error('Gemini non disponible');

  const model = genAI.getGenerativeModel({ 
    model: "gemini-1.5-flash",
    generationConfig: {
      temperature: 0.8, // Plus cr√©atif pour des insights personnalis√©s
      topK: 40,
      topP: 0.95,
      maxOutputTokens: 3000, // Plus de tokens pour une analyse approfondie
    },
    safetySettings: [
      {
        category: "HARM_CATEGORY_HARASSMENT",
        threshold: "BLOCK_MEDIUM_AND_ABOVE",
      },
      {
        category: "HARM_CATEGORY_HATE_SPEECH", 
        threshold: "BLOCK_MEDIUM_AND_ABOVE",
      }
    ]
  });

  // Prompt enrichi et structur√© pour Gemini
  const enhancedPrompt = `
Tu es un consultant senior expert en procurement avec 15+ ans d'exp√©rience. Analyse ce diagnostic achats et fournis une analyse personnalis√©e de haute qualit√©.

üìä **DONN√âES DU DIAGNOSTIC:**

**Score Global:** ${data.overallScore}% (Niveau: ${getMaturityLevel(data.overallScore)})

**Scores par Domaine:**
${Object.entries(data.percentages).map(([domain, score]) => 
  `‚Ä¢ ${formatDomainName(domain)}: ${score}% ${getPerformanceIndicator(score as number)}`
).join('\n')}

**Domaines Critiques (< 40%):**
${data.criticalDomains.length > 0 ? 
  data.criticalDomains.map(([domain, score]) => `‚Ä¢ ${formatDomainName(domain)}: ${score}%`).join('\n') : 
  '‚Ä¢ Aucun domaine critique identifi√©'}

**Domaines d\'Excellence (> 80%):**
${data.excellentDomains.length > 0 ? 
  data.excellentDomains.map(([domain, score]) => `‚Ä¢ ${formatDomainName(domain)}: ${score}%`).join('\n') : 
  '‚Ä¢ Aucun domaine d\'excellence identifi√©'}

**√âchantillon de R√©ponses D√©taill√©es:**
${data.answersDetail.map((answer: any) => 
  `‚Ä¢ ${answer.category}: ${answer.response} (Score: ${answer.score}/5)`
).join('\n')}

üéØ **CONTEXTE MIRIHI:**
Mirihi propose des diagnostics sp√©cialis√©s pour optimiser les achats :
‚Ä¢ **Orientation Strat√©gique**: Alignement, stakeholders, innovation collaborative
‚Ä¢ **Segmentation Cat√©gories**: Matrice Kraljic, strat√©gies d'approvisionnement  
‚Ä¢ **Gestion Fournisseurs**: SRM, clustering, √©valuation performance
‚Ä¢ **Maturit√© MMCM**: Assessment global sur 6 domaines de maturit√©

üöÄ **MISSION:**
G√©n√®re une analyse JSON avec intelligence et personnalisation:

{
  "insights": "Analyse narrative personnalis√©e (200-250 mots) avec:
    - Diagnostic global du profil de maturit√©
    - Analyse des patterns et coh√©rences
    - Mise en perspective des forces vs faiblesses  
    - Opportunit√©s business identifi√©es
    - Ton expert mais accessible, personnalis√©",
    
  "recommendations": [
    "4-5 recommandations concr√®tes et actionnables",
    "Prioris√©es par impact business vs effort",
    "Adapt√©es au niveau de maturit√© d√©tect√©", 
    "Avec mention des modules Mirihi pertinents"
  ],
  
  "nextSteps": [
    "4-5 √©tapes op√©rationnelles s√©quenc√©es",
    "Actions sp√©cifiques avec timeframe sugg√©r√©",
    "Ressources/comp√©tences n√©cessaires",
    "M√©triques de succ√®s propos√©es"
  ]
}

‚ö° **CONTRAINTES:**
- JSON valide uniquement, sans markdown
- Ton professionnel mais humain
- Insights personnalis√©s bas√©s sur les donn√©es r√©elles
- Recommandations gradu√©es selon la maturit√©
- Focus impact business et gains rapides

Analyse maintenant ces donn√©es et g√©n√®re ton expertise:`;

  try {
    const result = await model.generateContent(enhancedPrompt);
    const response = await result.response;
    const analysisText = response.text().trim();

    // Nettoyer le texte pour extraire le JSON
    let cleanJson = analysisText;
    if (cleanJson.includes('```json')) {
      cleanJson = cleanJson.split('```json')[1].split('```')[0].trim();
    } else if (cleanJson.includes('```')) {
      cleanJson = cleanJson.split('```')[1].split('```')[0].trim();
    }

    // Parser le JSON
    const analysis = JSON.parse(cleanJson);
    
    // Validation et enrichissement
    if (!analysis.insights || !analysis.recommendations || !analysis.nextSteps) {
      throw new Error('Structure JSON incompl√®te');
    }

    // Enrichir avec des donn√©es contextuelles
    analysis.metadata = {
      generatedAt: new Date().toISOString(),
      geminiModel: "gemini-1.5-flash",
      overallScore: data.overallScore,
      maturityLevel: getMaturityLevel(data.overallScore),
      priorityDomains: data.criticalDomains.map(([domain]) => formatDomainName(domain))
    };

    return analysis;

  } catch (parseError) {
    console.error('‚ùå Erreur parsing Gemini:', parseError);
    throw new Error('R√©ponse Gemini invalide');
  }
}

// Fallback intelligent en cas d'indisponibilit√© de Gemini
async function generateFallbackAnalysis(data: any): Promise<any> {
  const analysisData = prepareDataForAnalysis(data);
  
  // Logique intelligente bas√©e sur les scores
  const insights = generateIntelligentInsights(analysisData);
  const recommendations = generateSmartRecommendations(analysisData); 
  const nextSteps = generateActionableSteps(analysisData);

  return {
    insights,
    recommendations,
    nextSteps,
    metadata: {
      generatedAt: new Date().toISOString(),
      source: "fallback-intelligent",
      overallScore: analysisData.overallScore,
      maturityLevel: getMaturityLevel(analysisData.overallScore)
    }
  };
}
      recommendations: [
        "Renforcer le domaine avec le score le plus faible pour √©quilibrer le profil",
        "Capitaliser sur vos points forts pour cr√©er des synergies",
        "Prioriser les actions √† impact m√©tier imm√©diat",
        "Utiliser nos modules de diagnostic pour approfondir l'analyse"
      ],
      nextSteps: [
        "Choisir le module de diagnostic le plus adapt√© √† vos besoins",
        "R√©aliser une √©valuation d√©taill√©e de vos processus",
        "D√©finir un plan d'am√©lioration avec objectifs SMART",
        "Mettre en place des indicateurs de suivi de performance"
      ]
    };

    return NextResponse.json(fallbackAnalysis);
  }
}
